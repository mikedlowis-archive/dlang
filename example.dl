#------------------------------------------------------------------------------
# Literal Definition and Usage
#------------------------------------------------------------------------------
foo := Nil

# Nums
assert( 1 == 1,           "Positive integer parses correctly")
assert( -1 == -1,         "Negative integer parses correctly")
assert( 1.0 == 1.0,       "Parse postive floating point value without exponent")
assert( -1.0 == -1.0,     "Parse negative floating point value without exponent")
assert( 10.0e-1 == 1.0,   "Parse positive floating point value with exponent")
assert( -10.0e-1 == -1.0, "Parse negative floating point value with exponent")

# Char
assert('a',  "Parse a character")
assert('\a', "Parse escape sequence for alarm")
assert('\b', "Parse escape sequence for backspace")
assert('\n', "Parse escape sequence for newline")
assert('\r', "Parse escape sequence for return")
assert('\t', "Parse escape sequence for tab")
assert('\v', "Parse escape sequence for vertical tab")
#foo = '\xFF'  # Hex Value

# String
foo = "some string"
foo = "foo \a \b \f \n \r \t \v \' \" \\ \xFF bar"
foo = "12345"[2]

# Symbol
foo = $some_symbol

# Map
foo = {
    $foo : 1 + 1,
    "stuff" : 2 + 2,
    $stuff : 2 + 2,
    $bar : 3 + 3,
}

# Setting map elements
foo["stuff"] = 3
foo.stuff = 5

# Accessing map elements
#print( foo[$bar] )
#print( foo["stuff"] )
#print( foo.stuff )

# Vector
foo = []
foo = [1]
foo = [1,2,3]
foo = foo[1]
foo = [1,2,3,4,5][2]

# Setting Vector Elements
foo[2] = 6

# List
foo = ()
foo = (1,)
foo = (1,2,3)
foo = foo[1]
foo = (1,2,3,4,5)[2]

# Setting List Elements
foo[2] = 6

# Block
foo = { 1 + 1 }
foo = {|a| a + 1}
foo = {|a,b| a + b }
foo = foo(1,2)
foo = ({|a,b| a + b })(1,2)

#------------------------------------------------------------------------------
# Operators and Precedence Tests
#------------------------------------------------------------------------------


#------------------------------------------------------------------------------
# Macro Definition and Usage
#------------------------------------------------------------------------------

# Define a macro that represents a traditional if statement
@ if [
    (E B B) : exec_if($1, $2, $3),
    (E B)   : exec_if($1, $2),
]

test_result = false
if (1 < 2)
{
    test_result = true
}{
    test_result = false
}
assert( test_result, "First branch should be taken when test condition is true" )

test_result = false
if (1 > 2)
{
    test_result = false
}{
    test_result = true
}
assert( test_result, "Second branch should be taken when test condition is false" )

test_result = false
if (1 < 2)
{
    test_result = true
}
assert( test_result, "Branch should be taken when test condition is true" )

test_result = true
if (1 > 2)
{
    test_result = false
}
assert( test_result, "Branch should not be taken when test condition is false" )

#------------------------------------------------------------------------------
# Delayed Evaluation
#------------------------------------------------------------------------------

# Define a macro that will delay the evaluation of the following expression
@ delay [
    (E) : make_promise({ $1 })
]

# Define a macro that will force the evaluation of the following delayed statement
@ force [
    (E) : $1()
]

foo = delay 1 + 1
foo = force foo

